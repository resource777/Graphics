기초 컴퓨터 그래픽스 

[요구사항]
(a) 처음 프로그램을 수행시키면 자신이 설정한 적절한 크기의 윈도우가 화면에 뜬다.
- 구현 여부 : 예
- 작동 확인 방법 : 실행하면 바로 볼 수 있다.
- 구현 방법 :
glutInitWindowSize 함수로 생성될 윈도우의 크기, glutInitWindowPosition 함수로 생성될 윈도우의 위치를 설정, glutCreateWindow 함수를 호출하여 윈도우 생성

(b) SHIFT 키를 누른 상태에서 처음 왼쪽 마우스 버튼을 클릭하면 해당 커서 위치에 점이 그려진다. (중요) SHIFT 키를 누르지 않은 상태에서는 이 기능은 작동하지 않는다.
- 구현 여부 : 예
- 작동 확인 방법 : shift키를 누른 상태에서 왼쪽 마우스 버튼을 클릭한다.
- 구현 방법: 
점의 좌표가 윈도우 좌표계와 OpenGL 좌표계가 다르기 때문에 윈도우 좌표를 저장하는 int winpos[128][2] 2차원 배열과, OpenGL 좌표를 저장하는 float openpos[128][2] 2차원 배열을 사용했다. 또한 생성된 점의 개수를 저장하기 위해서 num 전역변수를 0으로 초기화하였다.
mousepress 함수에서 왼쪽 마우스 버튼을 누른 상태는 (button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN)을 만족하고, shift가 눌린 상태는 (glutGetModifiers() == GLUT_ACTIVE_SHIFT)을 만족하므로 두가지 조건을 모두 확인한다. 
mousepress 함수 내에서 실행되는 point_exist 함수에서는 기존의 생성된 점들의 opengl 좌표가 저장된 openpos 배열을 순차적으로 탐색하면서 같은 점이 두개가 저장되지 않도록 한다. 또한 저장된 점의 개수가 최대 128개로 제한되므로 num 변수의 값이 128인 경우에 이미 점이 128개 저장되어있다는 의미이므로, 메시지를 띄우고 같은 위치의 점이 생성되지 않도록 한다.
다각형이 만들어진 상태에서도 새로운 점을 생성하지 못하는 조건을 만족하기 위해 다각형이 만들어졌을 경우 플래그 polygon_exist가 1이 되기에 polygon_exist가 0일 때만 새로운 점에 대한 정보를 배열에 저장하게 된다. 이때 mousepress의 x, y 파라미터는 윈도우 창에서의 좌표이므로 각각을 opengl상의 좌표로 변환해야한다. 따라서 xwin2open, ywin2open 함수에서 각각 x, y를 openGL 좌표로 변환하여 openpos배열에 저장해준다. 
정상적으로 점이 생성되었을 경우 num값을 1 증가시키고, glutPostRedisplay 함수를 실행하면, display 함수가 실행되면서 변경된 배열 정보로 다시 그려주는 작업을 실행하게 된다. display 함수에서 반복문을 통해서 점의 개수만큼 openpos 배열에 저장된 값을 활용하여 점을 그려주는데 이때 생성되는 점은 파란색으로 크기는 10으로 설정했다.
 
(c) 이후 계속해서 SHIFT 키를 누른 상태에서 왼쪽 마우스 버튼을 클릭할 때마다 해당 커서 위치에 점이 그려지며, 이 점과 바로 직전의 점 사이에 선분이 그려진다.
(중요) SHIFT 키를 누르지 않은 상태에서 이 기능은 작동하지 않는다.
- 구현 여부 : 예
- 작동 확인 방법 : shift키를 누른 상태에서 왼쪽 마우스 버튼을 클릭을 두 번 이상 해본다.
- 구현 방법:
앞의 (b)에서 업데이트한 점의 개수 num과 openpos 배열을 이용하여 선분을 그리게 되는데, 선분을 그릴 수 있다는 것은 생성된 점의 개수가 최소 2개 이상이라는 의미이다. 따라서 display 함수에서 num이 1보다 큰 경우 반복문으로 이웃한 점끼리 선분을 그려준다. 예를 들면 num = 3 일때, (openpos[0][0],openpos[0][1]) 와 (openpos[1][0],openpos[1][1]) 을 이어주고, (openpos[1][0],openpos[1][1]) 와 (openpos[2][0],openpos[2][1]) 을 이어주면서 선분이 2개가 생기는 것이다. 선분의 너비는 4, 색은 녹색으로 지정해주었다.

(d) (최소 3개의 점을 선택한 상태에서) p 키를 누르면 가장 처음과 마지막에 선택한 점을 연결하는 선분이 그려지면서 다각형 (polygon)이 완성된다.
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 생성한 경우, 키보드로 p를 입력한다.  
- 구현 방법:
keyboard 함수에서 key가 ‘p’인 경우, num이 3이상이고 이미 다각형이 만들어진 경우가 아니라면 polygon_exist 플래그를 0에서 1로 바꿔준다. polygon_exist가 1이 되면서 다각형이 이제부터 존재하고 있다는 것을 의미하게 된다. 이후에 glutPostRedisplay 함수를 실행하면, display 함수에서는 polygon_exist가 1인 것을 확인하면서, openpos의 가장 첫번째 원소의 좌표와, 마지막으로 저장된 점의 좌표 간에 추가적으로 선분을 그려준다. 

(e) 점을 선택하였거나 다각형을 완성한 상태에서 c 키를 누르면 선택한 점과 선분들 또는 다각형이 모두 지워진다.
- 구현 여부 : 예
- 작동 확인 방법 : 키보드로 c를 입력한다.  
- 구현 방법:
keyboard 함수에서 key가 ‘c’인 경우 점의 개수를 저장하는 num변수를 0으로, polygon_exist 플래그를 0으로 변경하고 결과적으로 glutPostRedisplay 함수를 호출하면 그려진 도형이 모두 지워진 초기 윈도우 창이 그려진다.

(f) 최소 3개의 점을 선택하지 않는 상태에서 p 키를 누르면 콘솔 윈도우에 적절한 에러 메시지를 출력한다. 
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 미만으로 선택한 후에 키보드로 p를 입력한다.
- 구현 방법:
keyboard 함수에서 key가 ‘p’인 경우, else if(num<3)에서 YOU HAVE TO SELECT AT LEAST THREE POINTS." 라는 에러 메시지를 콘솔 윈도우에 출력하였다.

(g) 다각형을 완성한 상태에서는 SHIFT 키를 누른 상태에서 왼쪽 마우스 버튼을 클릭하더라도 이에 반응하지 않는다. 
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 찍은 이후, 키보드로 p를 입력하고 그 이후에 다시 shift를 누르며 왼쪽 마우스 클릭을 해본다.
- 구현 방법:
mousepress 함수에서 if문의 조건으로 ((button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN) && (glutGetModifiers() == GLUT_ACTIVE_SHIFT)) 을 만족하는 경우에 대해서 polygon_exist가 1인 경우에는 ***There is already a POLYGON!!! 이라는 메시지만 띄우고 좌표에 대한 변환이나 값의 저장은 하지 않게 구현하였다.

(h) (다각형을 완성한 상태에서) 왼쪽, 오른쪽, 위쪽, 그리고 아래쪽 화살표를 누를 때마다 이 다각
형은 적절한 양만큼 해당 방향으로 이동 (translation)한다.
(중요) 다각형이 완성되지 않은 상태에서는 이 기능은 작동하지 않는다.
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 찍은 이후, 키보드로 p를 입력하고 키보드 상하좌우 방향키를 눌러본다.
- 구현 방법:
다각형이 있을 때, 즉 polygon_exist가 1인 경우에 대해서 키보드 상하좌우의 입력은 special 함수에서 핸들링 되는데, 각 방향키는 GLUT_KEY_UP, GLUT_KEY_DOWN, GLUT_KEY_LEFT, GLUT_KEY_RIGHT 가 들어오면, p버튼을 누를 때 값이 정해진 무게중심 점을 포함한 다각형의 각 꼭짓점의 x축방향 혹은 y축방향의 openpos의 값을 0.1f만큼 증가 혹은 감소되도록 하였다. 그리고 glutPostRedisplay 함수를 호출하여 새로 변경된 좌표를 그린다.

(i) (다각형을 완성한 상태에서) 오른쪽 마우스 버튼을 클릭한 상태에서 마우스 커서를 움직이면
다각형이 마우스가 움직인 양만큼 해당 방향으로 이동한다.
(중요) 다각형이 완성되지 않은 상태에서는 이 기능은 작동하지 않는다.
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 찍은 이후, p를 입력하고 오른쪽 마우스 버튼을 누르면서 커서를 이동시켜본다. 
- 구현 방법:
mousepress 함수에서 (button == GLUT_RIGHT_BUTTON) && (state == GLUT_DOWN) 이라는 조건을 통과하면 마우스 오른쪽 버튼을 누르고 있다는 의미이다. 이때, rightbuttonpressed의 값이 1로 설정된다. 이때, 마우스의 윈도우 상 위치를 prev_x, prev_y에 저장해서 이후에 변경된 마우스 커서의 위치와 차이를 구할 수 있도록 하였다. 
mousemove 함수에서는 오른쪽 마우스버튼을 누르고 있는 상태(rightbuttonpressed==1) 이면서 polygon_exist(다각형이 존재한다) 인 상태에서 현재 마우스 커서의 위치와 prev_x,prev_y의 값을 각각 opengl 좌표계로 변환한 값의 차이를 각각 변수 del_x, del_y에 저장했다. 이후 모든 다각형의 점과 무게중심의 좌표에 그 값을 더해서 마우스 우클릭 중 커서를 움직이는 양만큼 해당 방향으로 이동 할 수 있도록 한다. 이후 glutPostRedisplay()를 통해서 다시 그려주고, prev_x와 prev_y의 값을 x, y로 업데이트한다.

(j) (다각형을 완성한 상태에서) r 키를 누르면 이 다각형은 자신의 무게 중심 점 둘레로 반시계 방
향으로 적절한 속도로 계속해서 회전한다.
(중요) 다각형이 완성되지 않은 상태에서는 이 기능은 작동하지 않는다.
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 찍은 이후, p를 입력하고 r을 입력한다. 
- 구현 방법:
p를 입력해 다각형을 만들 수 있는 경우, p를 누르면 그려지는 다각형의 무게중심의 좌표를 getarea함수와 getxg, getyg 함수를 실행하면서 구하게 된다. getarea 함수는 다각형의 각 좌표들을 가지고서 다각형의 면적을 구하는 역할을 하고, getxg,getyg 함수는 구해진 다각형의 면적과 좌표들을 가지고 무게중심의 x좌표, y좌표를 gravity_center[0], gravity_center[1]에 저장하는 역할을 한다. 
r을 누르게 되는 경우에 animation_exist가 0인 경우에 1이되고 1인경우에 0이 되는데, 0->1인 경우 회전을 시작하고 1->0이 되는 경우 기존의 회전이 멈추게 된다. glutTimerFunc는 재귀적으로 구현되어 있고 angle 변수에는 약 1도에 해당하는 값을 저장했다. 500밀리초에 1도씩 다각형의 무게중심 기준으로 꼭짓점들을 회전변환을 시켜서 좌표 값을 재할당 해주고, glutPostRedisplay함수를 호출해 바뀐 좌표 정보로 다시 그려준다. 

(k) 회전 중에는 이 다각형의 무게 중심에 해당하는 점이 그려진다. 
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개 이상 찍은 이후, p를 입력하고 r을 입력한다. 
- 구현 방법:
다각형을 만들면서 구한 무게중심의 좌표를 저장한 상태에서 r을 입력하면 animation_exist가 1이기 때문에 무게중심에 해당하는 좌표를 display 함수에서 그릴 수 있다. 이때, 무게중심점의 크기는 15, 색은 빨강색으로 설정하였다.

(l) 회전 상태에서 다시 r 키를 누르면 회전이 멈추고 무게 중심 점이 화면에서 사라진다. 
- 구현 여부 : 예
- 작동 확인 방법 : 회전하는 상태에서 r을 입력한다.
- 구현 방법:
r을 다시 누르게 되면 animation_exist가 0이 되면서 더 이상 glutTimerFunc 함수가 실행되지 않고 더 이상의 회전은 일어나지 않는다. 또한 display 함수에서도 무게중심 점은 animation_exist가 1인 상태에서만 그려지기에 glutPostRedisplay함수로 display함수를 다시 실행 했을 때, 회전이 멈추고 무게중심 점도 사라진 상태가 된다.

(m) 다각형이 회전하고 있는 상태에서는 새로운 점을 선택하거나 다각형을 지우거나 화살표 또는 마우스로 다각형을 이동하는 기능이 모두 정지된다. 
- 구현 여부 : 예
- 작동 확인 방법 : 회전하는 상태에서 shift+마우스 왼쪽클릭/ 키보드 c입력/키보드 상하좌우 입력/마우스 오른쪽 클릭하면서 커서이동을 해본다.
- 구현 방법:
앞에서 구현한 shift+마우스 왼쪽클릭/ 키보드 c입력/키보드 상하좌우 입력/마우스 오른쪽 클릭하면서 커서이동들에 대해서 animation_exist가 1인 경우에는 실행되지 않도록 조건문에 !animation_exist 조건이 포함되어있다.

(n) 마우스를 사용하여 윈도우의 크기를 변경하면 그에 맞게 가로-세로 비율을 유지하면서 윈도우의 내용이 변경되어야 한다.
- 구현 여부 : 예
- 작동 확인 방법 : 마우스를 사용하여 윈도우의 크기를 변경해본다.
- 구현 방법:
reshape 함수에서 윈도우의 너비와 높이 값을 각각 width, height 즉 바뀌는 값으로 변경하고 glViewport함수를 실행할 때 바뀐 사이즈의 값들을 파라미터로 넣어준다.

(o) f 키를 누르면 프로그램이 종료한다.
- 구현 여부 : 예
- 작동 확인 방법 : 키보드 f값을 입력한다.
- 구현 방법:
keyboard 함수에서 f를 입력한 경우에 대해서 glutLeaveMainLoop 함수를 실행시켜 메인함수에서돌아가던 무한루프를 벗어나고 이후 메인 함수가 종료된다.

(p) 윈도우 배경, 사용자가 선택한 점, 점들을 연결하는 선분, 그리고 다각형의 무게 중심 점은 모두 자신이 선택한 서로 다른 색깔로 그려진다.
- 구현 여부 : 예
- 작동 확인 방법 : 점을 3개이상 찍고, p를 눌러 다각형을 만든 후, r을 누르면 확인 가능하다.
- 구현 방법:
 float r = 0.7843, g = 0.6431, b = 0.7098; 로 설정해서 “habitat rose”라는 색으로 배경색을 설정했다.  display함수에서 glClearColor함수에서 해당 색으로 배경색을 설정하였다. 다각형 꼭짓점의 경우에는 glColor3f 함수에서 파란색, 선분의 경우에는 초록색, 무게중심의 경우에는 빨간색으로 설정해주었다.
